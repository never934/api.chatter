package com.tastyeem.apichatter.filtersimport com.tastyeem.apichatter.AppConstimport io.jsonwebtoken.Claimsimport io.jsonwebtoken.ExpiredJwtExceptionimport io.jsonwebtoken.Jwtsimport io.jsonwebtoken.MalformedJwtExceptionimport io.jsonwebtoken.UnsupportedJwtExceptionimport org.springframework.security.authentication.UsernamePasswordAuthenticationTokenimport org.springframework.security.core.context.SecurityContextHolderimport org.springframework.web.filter.OncePerRequestFilterimport java.io.IOExceptionimport java.security.SignatureExceptionimport javax.servlet.FilterChainimport javax.servlet.ServletExceptionimport javax.servlet.http.HttpServletRequestimport javax.servlet.http.HttpServletResponseclass JWTAuthorizationFilter : OncePerRequestFilter() {    @Throws(ServletException::class, IOException::class)    override fun doFilterInternal(request: HttpServletRequest, response: HttpServletResponse, chain: FilterChain) {        try {            if (checkJWTToken(request, response)) {                val claims: Claims = validateToken(request)                setUpSpringAuthentication(claims)            } else {                SecurityContextHolder.clearContext()            }            chain.doFilter(request, response)        } catch (e: SignatureException) {            response.status = HttpServletResponse.SC_FORBIDDEN            response.sendError(HttpServletResponse.SC_FORBIDDEN, e.message)            return        } catch (e: ExpiredJwtException) {            response.status = HttpServletResponse.SC_FORBIDDEN            response.sendError(HttpServletResponse.SC_FORBIDDEN, e.message)            return        } catch (e: UnsupportedJwtException) {            response.status = HttpServletResponse.SC_FORBIDDEN            response.sendError(HttpServletResponse.SC_FORBIDDEN, e.message)            return        } catch (e: MalformedJwtException) {            response.status = HttpServletResponse.SC_FORBIDDEN            response.sendError(HttpServletResponse.SC_FORBIDDEN, e.message)            return        }    }    private fun validateToken(request: HttpServletRequest): Claims {        val jwtToken = request.getHeader(AppConst.JWT_HEADER).replace(AppConst.JWT_PREFIX, "")        return Jwts.parser().setSigningKey(AppConst.JWT_SECRET).parseClaimsJws(jwtToken).body    }    /**     * Authentication method in Spring flow     *     * @param claims     */    private fun setUpSpringAuthentication(claims: Claims) {        val auth = UsernamePasswordAuthenticationToken(claims.getSubject(), null, null)        SecurityContextHolder.getContext().authentication = auth    }    private fun checkJWTToken(request: HttpServletRequest, res: HttpServletResponse): Boolean {        val authenticationHeader = request.getHeader(AppConst.JWT_HEADER)        return !(authenticationHeader == null || !authenticationHeader.startsWith(AppConst.JWT_PREFIX))    }}