package com.tastyeem.apichatter.controllersimport com.tastyeem.apichatter.models.db.Chatimport com.tastyeem.apichatter.models.db.ChatRequestimport com.tastyeem.apichatter.repository.ChatMessageRepositoryimport com.tastyeem.apichatter.repository.ChatRepositoryimport com.tastyeem.apichatter.repository.ChatRequestRepositoryimport com.tastyeem.apichatter.utils.TimeUtilsimport com.tastyeem.apichatter.utils.TokenUtilsimport io.swagger.annotations.Apiimport io.swagger.annotations.ApiOperationimport io.swagger.models.Responseimport org.springframework.http.HttpStatusimport org.springframework.http.ResponseEntityimport org.springframework.web.bind.annotation.*import java.util.*@RestController()@RequestMapping("/v1/chats/requests")@Api(value = "Auth", description = "user chat requests")class ChatRequestController(val chatRequestRepository: ChatRequestRepository, val chatRepository: ChatRepository) {    @RequestMapping(method = [RequestMethod.POST])    @ApiOperation(value = "request chat with user")    fun requestChat(@RequestHeader("Authorization") token: String, @RequestParam userId: String) : ResponseEntity<Any> {        val senderId = TokenUtils().getTokenUserId(token)        senderId?.let {            val time = TimeUtils().getUnixTime()            val chatRequests = chatRequestRepository.findAll()            val chat = chatRepository.findAll().filter { it.userIds.contains(senderId) && it.userIds.contains(userId) }            if(chat.isNotEmpty()){                // чат уже создан                return ResponseEntity(HttpStatus.NOT_ACCEPTABLE)            }            if(chatRequests.none { it.senderId == senderId && it.receiverId == userId}){                if(chatRequests.none{it.senderId == userId && it.receiverId == senderId}){                    chatRequestRepository.save(                        ChatRequest(                            id = UUID.randomUUID().toString(),                            senderId = senderId,                            receiverId = userId,                            createdDate = time,                            updatedDate = time                        )                    )                    // отправить пуш ресиверу о запросе нового чата                    return ResponseEntity(HttpStatus.OK)                }else{                    // невозможно отправить приглашение в чат этому человеку, так как он уже отправил вам приглашение                    return ResponseEntity(HttpStatus.UNAVAILABLE_FOR_LEGAL_REASONS)                }            }else{                // невозможно отправить приглашение в чат этому человеку, так как вы уже отправили его                return ResponseEntity(HttpStatus.TOO_MANY_REQUESTS)            }        } ?: run{            return ResponseEntity(HttpStatus.BAD_REQUEST)        }    }    @RequestMapping(method = [RequestMethod.GET])    @ApiOperation(value = "get chat requests")    fun getChatRequests(@RequestHeader("Authorization") token: String) : ResponseEntity<List<ChatRequest>> {        val userId = TokenUtils().getTokenUserId(token)        userId?.let {            return ResponseEntity.ok().body(chatRequestRepository.findAll().filter { it.senderId == userId || it.receiverId == userId })        } ?: run {            return ResponseEntity(HttpStatus.BAD_REQUEST)        }    }    @RequestMapping(method = [RequestMethod.POST], value = ["/{requestId}/answer"])    @ApiOperation(value = "answer for chat request")    fun answerForRequest(@RequestHeader("Authorization") token: String, @PathVariable requestId: String, @RequestParam answer: Boolean) : ResponseEntity<Any> {        val request = chatRequestRepository.findById(requestId).get()        val userId = TokenUtils().getTokenUserId(token) ?: ""        if(request.receiverId == userId){            if(answer){                val time = TimeUtils().getUnixTime()                chatRepository.save(                    Chat(                        id = UUID.randomUUID().toString(),                        userIds = listOf(request.senderId, request.receiverId),                        createdDate = time,                        updatedDate = time                    )                )                chatRequestRepository.deleteById(requestId)                // отправить пуш клиентам о создании чата                return ResponseEntity(HttpStatus.OK)            }else{                chatRequestRepository.deleteById(requestId)                // отправить пуш клиентам об отклонении чата                return ResponseEntity(HttpStatus.OK)            }        }else{            return ResponseEntity(HttpStatus.BAD_REQUEST)        }    }}